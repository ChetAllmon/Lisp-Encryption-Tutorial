<div class = "titleBar"> Lisp Encryption Tutorial </div>

<div class = "article"> 

  <div class = "headers"> The Caesar Cipher </div>

  <div class = "text"> 

      The Caesar Cipher is a simple way of encrypting a message. Just move every letter to the right in the alphabet as many times as desired.
      <br> <br>
    <div class = "examples">
      <br>
      In practice: 
      <br> <br>
      Message: "This is super secret" 
      <br> <br>
      When encrypted with a shift of one (1) becomes 
      <br> <br>
      Encrypted Message: "uijt jt tvqfs tfdsfu" 
      <br> <br>

      <div *ngFor = "let rotationBox of rotationBoxes " class = "rotationLockBoxes">
        {{rotationBox.letter}}
      </div>

      <span> Key Value is: {{keyValue}} </span>

      <br> <br>
      <div *ngFor = "let rotationBox of rotationBoxes " class = "rotationLockBoxes">
        {{rotationBox.letter}}
      </div>
    
      <span>
        <input type="text" #key>
        <button (click)="getTextBoxVal(key)">Set Key</button>
      </span>
      <div> <br> </div>
    </div>
 
    <!-- <div> {{rotationBoxes[2].letter}} </div> -->

    <br> 
    With a shift of one (1) each letter is shifted to the right once, A->B, B->C, C->D, ... Y->Z, Z->A, etc. 
    <br>
    This method of encrypting a message makes it very easy to decrypt, simply shift back whatever number you used as the shift to encrypt the message.
    <br> <br>
    For a more in-depth explanation of the CC, as well as seeing an encrypter/decrypter program in action, you can visit http://practicalcryptography.com/ciphers/caesar-cipher/
    <br> <br>
    You can use whatever shift you desire, even past 26(alphabet size, though this is the same as using a smaller number, I.E 27 shifts is the same as 2 shifts). 
    <br>
    However, the shift of 13 is the most common, this shift is known as ROT13. Our code will be able to use whatever shift number(key) the user desires to input.
    <br> <br>

    <div class = "headers"> The Caesar Cipher One Letter at a Time </div>

    <br>
    The simplest method of encoding a letter is to add the key to the letter itself. (+ "A" 1) However, we cannot add letters to numbers, so we must convert "A" to a number(int)
    <br> <br>
    We can use <code class="inline">(string->int "A")</code> to do this, the result is 65.
    <br> <br>
    (This is due to the ASCII table, which shows the number that a character is refered to as, (65 is A, 66 is B, etc) http://www.asciitable.com/)
    <br> <br>
    So, with a key of 1, A becomes (+  65 1) = 66. If we use (int->string 66) we get "B".
    <br> <br>
    Now we can decode this letter, doing the opposite.
    <br> <br>
    B changed to a number is 66, subtract the key, 65, 65 to a letter is "A".
    <br> <br>
    Now we can do this in code.
    <br> <br> 
    <div class = "examples">
      <code> 
        <br> 
        (check-expect (encode-one-letter "A")   65)
        <br>
        (check-expect (encode-one-letter "F")   70)
        <br>
        (check-expect (encode-one-letter "Z")   90)
        <br>  <br>

        <pre>
          (define (encode-one-letter letter) 
            (string->int letter))
        </pre>
        
        <br>  <br>
        (check-expect (encrypt-one-letter "A" 1) "B")
        <br> 
        (check-expect (encrypt-one-letter "F" 1) "G")
        <br> 
        (check-expect (encrypt-one-letter "Z" 1) "A") ;This test will fail as "A" is expected, but it returned "["
        <br>  <br>
        <pre>
        (define (encrypt-one-letter letter key)
          (int->string (+ (string->int letter) key)))
        </pre>
        <div> <br> </div>
      </code>
  
    </div>

    <div>
      <br>
      The above code works, however, if we try to change "Z", it does not go to "A" like we want. This is because of the ascii table. Z is 90 on the ASCII table, and [ is 91.
      <br>  <br>
      So, we have to account for the loop around of the alphabet. We can do this using modulo, which returns the remainder of 2 numbers. (modulo 5 3) = 2
      <br>  <br>
      Note that (modulo (0-25) 26) will return the number given (0-25) (modulo 20 26) = 20, etc. However (modulo 26 26) = 0; Which brings us back to "A".
      <br>  <br>
      
    </div>

    <div class = "examples">
      <code >
        <br>
        (check-expect (encrypt-one-letter-with-modulo "A" 1) "B")
        <br>  <br>
        (check-expect (encrypt-one-letter-with-modulo "F" 1) "G")
        <br>  <br>
        (check-expect (encrypt-one-letter-with-modulo "Z" 1) "A") ; No error thrown!
        <br>  <br>
        <pre>
        (define (encrypt-one-letter-with-modulo letter key)
          (int->string (+ 
          (string->int "A") 
          (modulo (- (+ (string->int letter) key) (string->int "A")) 26))))
        </pre>
      </code>
      ;Note: we can simply replace (string->int "A") with 65, as we know the value, this saves the computer minimal processor power, but it clears up the code a bit.
      <br>
      ;This is a matter of personal preference, if you prefer having the calculation to show where 65 came from feel free, you can also just add a comment to explain the 65.
      <br> <br>
      Ex:
      <br>
      <code>
        ;Origin of 65 in the following function: (string->int "A") = 65
        <pre>
          (define (encode-one-letter-with-modulo letter key)
          (int->string (+ 65 (modulo (- (+ (string->int letter) key) 65) 26))))
        </pre>
      </code>

    </div>
      
      <br>
      We now have a one letter encrypting function, what we need to be able to do is decrypt the resulting encrypted character. 
      <br> <br>
      So now we will create a one letter decrypting function.
      <br> <br>
      This is actually a very simple function to write. 
      <br> <br>
      Feel free to attempt it on your own before reading on.
      <br> <br>
      Hint: All you need to do is the opposite of the encrypt function.
      <br> <br>
   
      <div class = "examples">
      <code>
        <br> 
        (check-expect (decode-one-letter "A")   65)
        <br> <br>
        (check-expect (decode-one-letter "F")   70)
        <br> <br>
        (check-expect (decode-one-letter "Z")   90)
        <br> <br>
        ;NOTE: this is THE SAME FUNCTION as the encode function. 
        <br> <br>
        (define (decode-one-letter letter) 
        <br> <br>
        (string->int letter))
        <br> <br>
        (check-expect (decrypt-one-letter "B" 1) "A")
        <br> <br>
        (check-expect (decrypt-one-letter "F" 1) "E")
        <br> <br>
        ;(check-expect (decrypt-one-letter "A" 1) "Z")  
        <br> <br>
        ;Throws an error, "Z" is expected, returned "@"
        <br> <br>
        
        (define (decrypt-one-letter letter key)
        <br> <br>
        (int->string (- (string->int letter) key)))
        <br> <br>
        
        (check-expect (decrypt-one-letter-with-modulo "B" 1) "A")
        <br> <br>
        (check-expect (decrypt-one-letter-with-modulo "G" 1) "F")
        <br> <br>
        (check-expect (decrypt-one-letter-with-modulo "A" 1) "Z") 
        <br> <br>
        ;No error thrown!
        <br> <br>
        
        (define (decrypt-one-letter-with-modulo letter key)
        <br> <br>
        (int->string (+ 
        <br> <br>
        (string->int "A") 
        <br> <br>
        (modulo (- (- (string->int letter) key) (string->int "A")) 26))))
        <br> <br>
        ;Now we can encrypt and decrypt a single character. 
        <br> <br>
        (encrypt-one-letter-with-modulo "A" 1) ; Outputs "B"
        <br> <br>
        (decrypt-one-letter-with-modulo "B" 1) ; Outputs "A"
        <br> 
        </code>
        <div> <br> </div>
      </div>
       
      <br>
      <div class = "headers"> Anonymous Functions </div>
       
      <div class = "examples">
      <br> 
      ;A standard function
      <br> <br>
      <code>
        (define (times-five x)
        <br> <br>
        (* x 5))
        <br> <br>
        ;Calling the function
        <br> <br>
        (times-five 4)
        <br> <br>
        ;OUTPUTS -> 20
        <br> <br>
        ;A standard function used in another function
        <br> <br>
        (map times-five
        <br> <br>
        (list 1 2 3))
        <br> <br>
        ;OUTPUTS -> (list 5 10 15)
        <br> <br>
        ;An Anonymous function used in a lambda
        <br> <br>
        (map (lambda(x)
        <br> <br>
        (* x 5))
        <br> <br>
        (list 1 2 3))
        <br> <br>
        ;OUTPUTS -> (list 5 10 15)
        <br> 
        </code>
        <div> <br> </div>
      </div>

      <div>
      <br> 
      Note:
      <br> <br>
      That (* x 5) is not defined anywhere.
      <br> <br>
      This anonymous function (* x 5) is not declared or used anywhere else.
      <br> <br>
      This allows for quick, one-time functions, to be created and used without cluttering up your code.
      <br> <br>
      It can also speed up your program significantly on large-scale programs (compared to defining a function each time).
      <br> <br>
      Note that anonymous functions are created at run-time.
      <div> <br> </div>
      </div>
      <br>
      <div class = "headers"> What is Currying? </div>
      <br>
      <div>
      “… currying is the technique of translating the evaluation of a function that takes multiple arguments into 
      evaluating a sequence of functions, each with a single argument. 
      <br> <br>
      For example, a function that takes two arguments, one from X and one from Y, 
      and produces outputs in Z, by currying is translated into a function that takes a single argument from X 
      and produces as outputs functions from Y to Z.”  -Wikipedia
      <br> <br>
      This can be difficult to understand so let’s look at an example.
      <br> 
      </div>

      <div class = "examples">
        <br> 
        <code> <pre>
          
          (define times
            (lambda (y)
              (* 4 y)))
             
          (times 5) ; OUTPUTS: 20
        
          ;In the above example, we see a simple curried example of (* 4 y) -> output.
          
          ;In this case, y is 5.
          
          (define add
            (lambda (x)
             (lambda (y)
               (+ x y))))
               
          (add 5) ;OUTPUTS: (lambda (a1) …)
          
          (define addit (add 5))
          
          (addit 4) ;OUTPUTS: 9
          
          </pre> </code>
          ;In the above example, we see a more complex nested curried function. This 
          <br> <br>
          ;allows us to enter two variables into the function. (+ x y) -> output.
          <br> <br>
          ;In this case, x is 5 and y is 4, although it does not matter as this is addition.
          <br>
      </div>

      <br>
      <div class = "headers"> The Caesar Cipher with a full message, using Currying</div>
      <br>

      Of course, we would like to be able to encrypt and decrypt a message without calling a function for every single character 
      in the message. 
      <br> <br>
      This is where we can use what we have learned from the single character encrypter and decrypter. 
      <br> <br>
      By placing components of them into a new function(s) we can create a function(s) that can encrypt or decrypt a string. 
      <br> <br>
      <div class = "examples">
        <br>
        <code> <pre>
          (check-expect ((create-encode-character-function 1) "A") "B") 

          (define (create-encode-character-function key)
          
            (lambda(letter) (int->string (+ 
              (string->int "A") 
              (modulo (- (+ (string->int letter) key) (string->int "A")) 26)))))
          
          (define (encrypt-message message key)
            (implode (map (create-encode-character-function key) (explode message))))
          
          (encrypt-message "HELLO" 1)
          
          (define (decode-character-function key)
            (lambda(letter) (int->string (+ 
              (string->int "A") 
              (modulo (+ (- (string->int letter) key) (string->int "A")) 26)))))
          
          (define (decrypt-message message key)
            (implode (map (decode-character-function key) (explode message))))
          
          (decrypt-message "IFMMP" 1) 
      
          (encrypt-message "HOWAREYOU" 5) ;OUTPUTS: "MTBFWJDTZ"
          (decrypt-message "MTBFWJDTZ" 5) ;OUTPUTS: "HOWAREYOU"
          
          (encrypt-message "ABCDEFGHIJKLMNOPQRSTUVWXYZ" 1) 
          ;OUTPUTS:        "BCDEFGHIJKLMNOPQRSTUVWXYZA"
              
          (decrypt-message "BCDEFGHIJKLMNOPQRSTUVWXYZA" 1)
          ;OUTPUTS:        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
          <br>
        </pre> </code>
      </div>

      We now have a fully working encryption/decryption function.
      Note that spaces will not work properly, nor punctuation marks. These functions are made only for alphabetical characters.
      <br> <br>

      <pre class = examples>

        (encrypt-message "HOWAREYOU" 5) ;OUTPUTS: "MTBFWJDTZ"
        (decrypt-message "MTBFWJDTZ" 5) ;OUTPUTS: "HOWAREYOU"

        (encrypt-message "ABCDEFGHIJKLMNOPQRSTUVWXYZ" 1) 
        ;OUTPUTS:        "BCDEFGHIJKLMNOPQRSTUVWXYZA"
    
        (decrypt-message "BCDEFGHIJKLMNOPQRSTUVWXYZA" 1)
        ;OUTPUTS:        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      </pre>

      <div class = headers>
        A Modern Cipher: Streaming Cipher
      </div>
      <br> <br> 
      Now we can create new versions of these functions which will use a random key. 
      <br> <br> 
      This means the code is much more difficult to decrypt unless you have the correct seed and random number.
      <br> <br> 
      A seed is the number placed into a slew of functions that "randomize" the value. 
      <br> <br> 
      In this case, the key is the seed and the random number is (random 26). 
      <br> <br> 
      Both of these numbers can be changed. Thus making it a stronger encryption.
      <br> <br> 
      Because a computer can't actually randomize a number, 
      <br> <br> 
      we can get the same number repeatedly by calling random when the key is the same. 
      <br> <br> 
      <pre class = examples>

      (random 26) ;outputs 0

      If you run this again, they will output the same values.

      (define key 10)

      (random-seed key)

      (define (lock) (random 26))

      lock ; This gives the value (key) to shift the messages characters by. 

      (check-expect (encode-char "B") "C")
      (check-expect (encode-char "L") "E")

      (check-expect (decode-char "C") "J")
      (check-expect (decode-char "B") "O")

      (define (encode-char char)
        (int->string (+ 
          (string->int "A") 
          (modulo (- (+ (string->int char) (lock)) (string->int "A")) 26))))

      (define (decode-char char)
        (int->string (+ 
          (string->int "A") 
          (modulo (- (- (string->int char) (lock)) (string->int "A")) 26))))

      (check-expect ((encode-char-function) "A") "U")
      (check-expect ((encode-char-function) "B") "U")

      (check-expect ((decode-char-function) "D") "G")
      (check-expect ((decode-char-function) "Z") "T")
      (check-expect ((decode-char-function) "D") "J") 

      (define (encode-char-function)
        (lambda(letter) (int->string (+
          (string->int "A") 
          (modulo (- (+ (string->int letter) (lock)) (string->int "A")) 26)))))

      (define (encrypt-message-rand message)
        (implode (map (encode-char-function) (explode message))))

      (encrypt-message-rand "HELLO")

      (define (decode-char-function)
        (lambda(letter) (int->string (+ 
          (string->int "A") 
          (modulo (+ (- (string->int letter) (lock)) (string->int "A")) 26)))))
      
      (define (decrypt-message-rand message)
        (implode (map (decode-char-function) (explode message))))

      (random-seed key)
      (decrypt-message-rand "KJLEY")

      (random-seed key)
      (encrypt-message-rand "AAAAA")
      (random-seed key)
      (decrypt-message-rand "DFATK")
                    
      (set! key 5) ; This redefines key to be 5
      (random-seed key)

      (encrypt-message-rand "HELLO")
      (random-seed key)
      (decrypt-message-rand "RHGJX")              
      </pre>
  </div>

</div>



